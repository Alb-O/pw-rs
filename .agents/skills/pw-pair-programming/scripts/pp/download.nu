use ../pw.nu

use ./project.nu *

# Download a sandbox file from the Navigator
# Fetches files generated by the Code Interpreter (python_user_visible)
export def "pp download" [
    --output (-o): path   # Save to file (defaults to stdout)
    --index (-i): int     # Which download link to use (0-indexed, default: last)
    --list (-l)           # List available download links instead of downloading
]: nothing -> any {
    ensure-project-tab | ignore

    let token_js = "(() => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/auth/session', false);
        xhr.withCredentials = true;
        xhr.send();
        if (xhr.status !== 200) return { error: 'Failed to get session' };
        const session = JSON.parse(xhr.responseText);
        return { token: session.accessToken };
    })()"
    let token_result = (pw eval $token_js).data.result
    if ($token_result | get -o error | is-not-empty) {
        error make { msg: ($token_result.error) }
    }
    let access_token = $token_result.token

    let links_js = "(() => {
        const links = [];
        const messages = document.querySelectorAll('[data-message-author-role=\"assistant\"]');

        messages.forEach(msg => {
            const messageId = msg.dataset.messageId;
            const anchors = msg.querySelectorAll('a.cursor-pointer');

            anchors.forEach(a => {
                const fiberKey = Object.keys(a).find(k => k.startsWith('__reactFiber'));
                if (!fiberKey) return;

                let fiber = a[fiberKey];
                while (fiber) {
                    const props = fiber.memoizedProps || fiber.pendingProps;
                    if (props?.href?.startsWith('sandbox:')) {
                        links.push({
                            messageId: messageId,
                            sandboxPath: props.href.replace('sandbox:', ''),
                            linkText: a.textContent
                        });
                        break;
                    }
                    fiber = fiber.return;
                }
            });
        });

        return links;
    })()"
    let links = (pw eval $links_js).data.result

    if ($links | length) == 0 {
        error make { msg: "No download links found in conversation" }
    }

    if $list {
        return ($links | enumerate | each { |item|
            {
                index: $item.index
                file: ($item.item.sandboxPath | path basename)
                path: $item.item.sandboxPath
                label: $item.item.linkText
            }
        })
    }

    let link_index = if ($index | is-empty) { ($links | length) - 1 } else { $index }
    let max_index = ($links | length) - 1
    if $link_index < 0 or $link_index > $max_index {
        error make { msg: $"Invalid index ($link_index). Available: 0-($max_index)" }
    }
    let link = ($links | get $link_index)

    let conv_id_js = "window.location.pathname.match(/\\/c\\/([a-f0-9-]+)/)?.[1] || null"
    let conv_id = (pw eval $conv_id_js).data.result
    if ($conv_id | is-empty) {
        error make { msg: "Could not determine conversation ID from URL" }
    }

    let msg_id_json = ($link.messageId | to json)
    let sandbox_path_json = ($link.sandboxPath | to json)
    let token_json = ($access_token | to json)

    let download_js = "(function() {
        const apiUrl = '/backend-api/conversation/" + $conv_id + "/interpreter/download?' +
            'message_id=' + encodeURIComponent(" + $msg_id_json + ") +
            '&sandbox_path=' + encodeURIComponent(" + $sandbox_path_json + ");

        const xhr = new XMLHttpRequest();
        xhr.open('GET', apiUrl, false);
        xhr.setRequestHeader('Authorization', 'Bearer ' + " + $token_json + ");
        xhr.withCredentials = true;
        xhr.send();

        if (xhr.status !== 200) {
            return { error: 'API request failed: ' + xhr.status + ' ' + xhr.responseText };
        }
        return JSON.parse(xhr.responseText);
    })()"

    let download_result = (pw eval-js $download_js)

    if ($download_result | get -o error | is-not-empty) {
        error make { msg: ($download_result.error) }
    }

    let download_url = $download_result.download_url
    if ($download_url | is-empty) {
        error make { msg: "No download URL in response" }
    }

    let download_url_json = ($download_url | to json)
    let content_js = "(function() {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', " + $download_url_json + ", false);
        xhr.withCredentials = true;
        xhr.send();
        return { status: xhr.status, content: xhr.responseText };
    })()"

    let content_result = (pw eval-js $content_js)
    if $content_result.status != 200 {
        error make { msg: $"Failed to fetch content: status ($content_result.status)" }
    }

    let content = $content_result.content

    if ($output | is-not-empty) {
        mkdir ($output | path dirname)
        $content | save -f $output
        { saved: $output, size: ($content | str length), file: ($link.sandboxPath | path basename) }
    } else {
        $content
    }
}
