use clap::{Parser, Subcommand, ValueEnum};
use std::path::PathBuf;

use crate::output::OutputFormat;
use crate::styles::cli_styles;
use crate::types::BrowserKind;

#[derive(Parser, Debug)]
#[command(name = "pw")]
#[command(about = "Playwright CLI - Browser automation from the command line")]
#[command(version)]
#[command(styles = cli_styles())]
pub struct Cli {
    /// Increase verbosity (-v info, -vv debug)
    #[arg(short, long, global = true, action = clap::ArgAction::Count)]
    pub verbose: u8,

    /// Output format: json (default), ndjson, or text
    #[arg(short = 'f', long, global = true, value_enum, default_value = "json")]
    pub format: CliOutputFormat,

    /// Load authentication state from file (cookies, localStorage)
    #[arg(long, global = true, value_name = "FILE")]
    pub auth: Option<PathBuf>,

    /// Browser to use for automation
    #[arg(short, long, global = true, value_enum, default_value = "chromium")]
    pub browser: BrowserKind,

    /// Connect to an existing CDP endpoint instead of launching a browser
    #[arg(long, global = true, value_name = "URL")]
    pub cdp_endpoint: Option<String>,

    /// Launch a reusable local browser server and persist its endpoint
    #[arg(long, global = true)]
    pub launch_server: bool,

    /// Disable project detection (use current directory paths)
    #[arg(long, global = true)]
    pub no_project: bool,

    /// Named context to load for this run
    #[arg(long, global = true, value_name = "NAME")]
    pub context: Option<String>,

    /// Disable contextual inference/caching for this invocation
    #[arg(long, global = true)]
    pub no_context: bool,

    /// Do not persist command results back to context store
    #[arg(long, global = true)]
    pub no_save_context: bool,

    /// Clear cached context data before running
    #[arg(long, global = true)]
    pub refresh_context: bool,

    /// Base URL used when URL argument is relative or omitted
    #[arg(long, global = true, value_name = "URL")]
    pub base_url: Option<String>,

    #[command(subcommand)]
    pub command: Commands,
}

/// CLI output format (clap-compatible enum)
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, ValueEnum)]
pub enum CliOutputFormat {
    /// JSON output (default, best for agents)
    #[default]
    Json,
    /// Newline-delimited JSON (streaming)
    Ndjson,
    /// Human-readable text
    Text,
}

impl From<CliOutputFormat> for OutputFormat {
    fn from(f: CliOutputFormat) -> Self {
        match f {
            CliOutputFormat::Json => OutputFormat::Json,
            CliOutputFormat::Ndjson => OutputFormat::Ndjson,
            CliOutputFormat::Text => OutputFormat::Text,
        }
    }
}

#[derive(Subcommand, Debug)]
pub enum Commands {
    /// Navigate to URL and check for console errors
    #[command(alias = "nav")]
    Navigate {
        /// Target URL (uses context when omitted)
        url: Option<String>,
    },

    /// Capture console messages and errors
    #[command(alias = "con")]
    Console {
        /// Target URL (uses context when omitted)
        url: Option<String>,
        /// Time to wait for console messages (ms)
        #[arg(default_value = "3000")]
        timeout_ms: u64,
    },

    /// Evaluate JavaScript and return result
    Eval {
        /// JavaScript expression to evaluate
        expression: String,
        /// Target URL (uses context when omitted)
        url: Option<String>,
    },

    /// Get HTML content (full page or specific selector)
    Html {
        /// Target URL (uses context when omitted)
        url: Option<String>,
        /// CSS selector (uses last selector or defaults to html)
        selector: Option<String>,
    },

    /// Get coordinates for first matching element
    Coords {
        url: Option<String>,
        selector: Option<String>,
    },

    /// Get coordinates and info for all matching elements
    CoordsAll {
        url: Option<String>,
        selector: Option<String>,
    },

    /// Take screenshot
    #[command(alias = "ss")]
    Screenshot {
        /// Target URL (uses context when omitted)
        url: Option<String>,
        /// Output file path (uses context or defaults when omitted)
        #[arg(short, long, value_name = "FILE")]
        output: Option<PathBuf>,
        /// Capture the full scrollable page instead of just the viewport
        #[arg(long)]
        full_page: bool,
    },

    /// Click element and show resulting URL
    Click {
        url: Option<String>,
        selector: Option<String>,
    },

    /// Get text content of element
    Text {
        url: Option<String>,
        selector: Option<String>,
    },

    /// List interactive elements (buttons, links, inputs, selects)
    #[command(alias = "els")]
    Elements { url: Option<String> },

    /// Wait for condition (selector, timeout, or load state)
    Wait {
        url: Option<String>,
        /// Condition to wait for (selector, timeout ms, or load state)
        #[arg(default_value = "networkidle")]
        condition: String,
    },

    /// Authentication and session management
    Auth {
        #[command(subcommand)]
        action: AuthAction,
    },

    /// Session lifecycle and inspection
    Session {
        #[command(subcommand)]
        action: SessionAction,
    },

    /// Initialize a new playwright project structure
    Init {
        /// Project directory (defaults to current directory)
        #[arg(default_value = ".")]
        path: PathBuf,

        /// Template type: standard (full structure) or minimal (tests only)
        #[arg(long, short, default_value = "standard", value_enum)]
        template: InitTemplate,

        /// Skip creating playwright.config.js
        #[arg(long)]
        no_config: bool,

        /// Skip creating example test file
        #[arg(long)]
        no_example: bool,

        /// Use TypeScript for config and tests
        #[arg(long)]
        typescript: bool,

        /// Force overwrite existing files
        #[arg(long, short)]
        force: bool,

        /// Generate Nix browser setup script (for NixOS/Nix users)
        #[arg(long)]
        nix: bool,
    },

    /// Run the CDP relay server for the browser extension bridge
    Relay {
        /// Host to bind
        #[arg(long, default_value = "127.0.0.1")]
        host: String,
        /// Port to bind
        #[arg(long, default_value_t = 19988)]
        port: u16,
    },
}

/// Project template type for init command
#[derive(Clone, Debug, ValueEnum, Default)]
pub enum InitTemplate {
    /// Full structure: tests/, scripts/, results/, reports/, screenshots/
    #[default]
    Standard,
    /// Minimal structure: tests/ only
    Minimal,
}

#[derive(Subcommand, Debug)]
pub enum AuthAction {
    /// Interactive login - opens browser for manual login, then saves session
    Login {
        /// URL to navigate to for login (uses context when omitted)
        url: Option<String>,
        /// File to save authentication state to
        #[arg(short, long, default_value = "auth.json")]
        output: PathBuf,
        /// Wait time in seconds for manual login (default: 60)
        #[arg(short, long, default_value = "60")]
        timeout: u64,
    },

    /// Show cookies for a URL (uses saved auth if --auth provided)
    Cookies {
        /// URL to get cookies for
        url: Option<String>,
        /// Output format: json or table
        #[arg(short, long, default_value = "table")]
        format: String,
    },

    /// Show contents of a saved auth file
    Show {
        /// File to read authentication state from
        file: PathBuf,
    },
}

#[derive(Subcommand, Debug)]
pub enum SessionAction {
    /// Show session descriptor status for the active context
    Status,
    /// Remove stored session descriptor for the active context
    Clear,
    /// Start a reusable local browser session and persist its endpoint
    Start {
        /// Run with a visible (headful) browser window
        #[arg(long)]
        headful: bool,
    },
    /// Stop the reusable local browser session and remove descriptor
    Stop,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_screenshot_command() {
        let args = vec![
            "pw",
            "screenshot",
            "https://example.com",
            "-o",
            "/tmp/test.png",
        ];
        let cli = Cli::try_parse_from(args).unwrap();

        match cli.command {
            Commands::Screenshot {
                url,
                output,
                full_page,
            } => {
                assert_eq!(url.as_deref(), Some("https://example.com"));
                assert_eq!(output, Some(PathBuf::from("/tmp/test.png")));
                assert!(!full_page);
            }
            _ => panic!("Expected Screenshot command"),
        }
    }

    #[test]
    fn parse_screenshot_default_output() {
        let args = vec!["pw", "screenshot", "https://example.com"];
        let cli = Cli::try_parse_from(args).unwrap();

        match cli.command {
            Commands::Screenshot {
                url,
                output,
                full_page,
            } => {
                assert_eq!(url.as_deref(), Some("https://example.com"));
                assert_eq!(output, None);
                assert!(!full_page);
            }
            _ => panic!("Expected Screenshot command"),
        }
    }

    #[test]
    fn parse_html_command() {
        let args = vec!["pw", "html", "https://example.com", "div.content"];
        let cli = Cli::try_parse_from(args).unwrap();

        match cli.command {
            Commands::Html { url, selector } => {
                assert_eq!(url.as_deref(), Some("https://example.com"));
                assert_eq!(selector.as_deref(), Some("div.content"));
            }
            _ => panic!("Expected Html command"),
        }
    }

    #[test]
    fn parse_wait_command() {
        let args = vec!["pw", "wait", "https://example.com", "networkidle"];
        let cli = Cli::try_parse_from(args).unwrap();

        match cli.command {
            Commands::Wait { url, condition } => {
                assert_eq!(url.as_deref(), Some("https://example.com"));
                assert_eq!(condition, "networkidle");
            }
            _ => panic!("Expected Wait command"),
        }
    }

    #[test]
    fn verbose_flag_short_and_long() {
        let short_args = vec!["pw", "-v", "screenshot", "https://example.com"];
        let short_cli = Cli::try_parse_from(short_args).unwrap();
        assert_eq!(short_cli.verbose, 1);

        let long_args = vec!["pw", "--verbose", "screenshot", "https://example.com"];
        let long_cli = Cli::try_parse_from(long_args).unwrap();
        assert_eq!(long_cli.verbose, 1);

        let double_v = vec!["pw", "-vv", "screenshot", "https://example.com"];
        let double_cli = Cli::try_parse_from(double_v).unwrap();
        assert_eq!(double_cli.verbose, 2);
    }

    #[test]
    fn parse_cdp_endpoint_flag() {
        let args = vec![
            "pw",
            "--cdp-endpoint",
            "ws://localhost:19988/cdp",
            "navigate",
            "https://example.com",
        ];
        let cli = Cli::try_parse_from(args).unwrap();
        assert_eq!(
            cli.cdp_endpoint.as_deref(),
            Some("ws://localhost:19988/cdp")
        );
    }

    #[test]
    fn parse_relay_command() {
        let args = vec!["pw", "relay", "--host", "0.0.0.0", "--port", "3000"];
        let cli = Cli::try_parse_from(args).unwrap();
        match cli.command {
            Commands::Relay { host, port } => {
                assert_eq!(host, "0.0.0.0");
                assert_eq!(port, 3000);
            }
            _ => panic!("Expected Relay command"),
        }
    }

    #[test]
    fn invalid_command_fails() {
        let args = vec!["pw", "unknown-command", "https://example.com"];
        assert!(Cli::try_parse_from(args).is_err());
    }
}
