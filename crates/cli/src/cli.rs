use clap::{Parser, Subcommand, ValueEnum};
use std::path::PathBuf;

use crate::output::OutputFormat;
use crate::styles::cli_styles;
use crate::types::BrowserKind;

/// HAR content policy (CLI wrapper for pw::HarContentPolicy)
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, ValueEnum)]
pub enum CliHarContentPolicy {
    /// Include content inline (base64)
    Embed,
    /// Store content in separate files
    #[default]
    Attach,
    /// Omit content entirely
    Omit,
}

impl From<CliHarContentPolicy> for pw::HarContentPolicy {
    fn from(policy: CliHarContentPolicy) -> Self {
        match policy {
            CliHarContentPolicy::Embed => pw::HarContentPolicy::Embed,
            CliHarContentPolicy::Attach => pw::HarContentPolicy::Attach,
            CliHarContentPolicy::Omit => pw::HarContentPolicy::Omit,
        }
    }
}

/// HAR recording mode (CLI wrapper for pw::HarMode)
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, ValueEnum)]
pub enum CliHarMode {
    /// Store all content
    #[default]
    Full,
    /// Store only essential content for replay
    Minimal,
}

impl From<CliHarMode> for pw::HarMode {
    fn from(mode: CliHarMode) -> Self {
        match mode {
            CliHarMode::Full => pw::HarMode::Full,
            CliHarMode::Minimal => pw::HarMode::Minimal,
        }
    }
}

// Re-export OutputFormat for backwards compatibility
pub use crate::output::OutputFormat as CliOutputFormat;

#[derive(Parser, Debug)]
#[command(name = "pw")]
#[command(about = "Playwright CLI - Browser automation from the command line")]
#[command(version)]
#[command(styles = cli_styles())]
pub struct Cli {
    /// Increase verbosity (-v info, -vv debug)
    #[arg(short, long, global = true, action = clap::ArgAction::Count)]
    pub verbose: u8,

    /// Output format: toon (default), json, ndjson, or text
    #[arg(short = 'f', long, global = true, value_enum, default_value = "toon")]
    pub format: OutputFormat,

    /// Load authentication state from file (cookies, localStorage)
    #[arg(long, global = true, value_name = "FILE")]
    pub auth: Option<PathBuf>,

    /// Browser to use for automation
    #[arg(short, long, global = true, value_enum, default_value = "chromium")]
    pub browser: BrowserKind,

    /// Connect to an existing CDP endpoint instead of launching a browser
    #[arg(long, global = true, value_name = "URL")]
    pub cdp_endpoint: Option<String>,

    /// Launch a reusable local browser server and persist its endpoint
    #[arg(long, global = true)]
    pub launch_server: bool,

    /// Disable daemon usage for this invocation
    #[arg(long, global = true)]
    pub no_daemon: bool,

    /// Disable project detection (use current directory paths)
    #[arg(long, global = true)]
    pub no_project: bool,

    /// Named context to load for this run
    #[arg(long, global = true, value_name = "NAME")]
    pub context: Option<String>,

    /// Disable contextual inference/caching for this invocation
    #[arg(long, global = true)]
    pub no_context: bool,

    /// Do not persist command results back to context store
    #[arg(long, global = true)]
    pub no_save_context: bool,

    /// Clear cached context data before running
    #[arg(long, global = true)]
    pub refresh_context: bool,

    /// Base URL used when URL argument is relative or omitted
    #[arg(long, global = true, value_name = "URL")]
    pub base_url: Option<String>,

    /// Directory to save artifacts (screenshot, HTML) on command failure
    #[arg(long, global = true, value_name = "DIR")]
    pub artifacts_dir: Option<std::path::PathBuf>,

    /// Record network activity to HAR (HTTP Archive) file
    #[arg(long, global = true, value_name = "FILE")]
    pub har: Option<PathBuf>,

    /// HAR content policy: embed (inline base64), attach (separate files), or omit
    #[arg(long, global = true, value_enum, default_value = "attach")]
    pub har_content: CliHarContentPolicy,

    /// HAR recording mode: full (all content) or minimal (essential for replay)
    #[arg(long, global = true, value_enum, default_value = "full")]
    pub har_mode: CliHarMode,

    /// Omit request/response content from HAR recording
    #[arg(long, global = true)]
    pub har_omit_content: bool,

    /// URL pattern filter for HAR recording (glob pattern)
    #[arg(long, global = true, value_name = "PATTERN")]
    pub har_url_filter: Option<String>,

    /// Block requests matching URL pattern (glob, can be used multiple times)
    #[arg(long, global = true, value_name = "PATTERN", action = clap::ArgAction::Append)]
    pub block: Vec<String>,

    /// Load request blocking patterns from file (one pattern per line)
    #[arg(long, global = true, value_name = "FILE")]
    pub block_file: Option<PathBuf>,

    /// Directory to save downloaded files (enables download tracking)
    #[arg(long, global = true, value_name = "DIR")]
    pub downloads_dir: Option<PathBuf>,

    /// Timeout for navigation and wait operations in milliseconds
    #[arg(long, global = true, value_name = "MS")]
    pub timeout: Option<u64>,

    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand, Debug)]
pub enum Commands {
    /// Navigate to URL and check for console errors
    #[command(alias = "nav")]
    Navigate {
        /// Target URL (positional, uses context when omitted)
        url: Option<String>,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
    },

    /// Take screenshot
    #[command(alias = "ss")]
    Screenshot {
        /// Target URL (positional, uses context when omitted)
        url: Option<String>,
        /// Output file path (uses context or defaults when omitted)
        #[arg(short, long, value_name = "FILE")]
        output: Option<PathBuf>,
        /// Capture the full scrollable page instead of just the viewport
        #[arg(long)]
        full_page: bool,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
    },

    /// Click element and show resulting URL
    Click {
        /// Target URL (positional)
        url: Option<String>,
        /// CSS selector (positional)
        selector: Option<String>,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
        /// CSS selector (named alternative)
        #[arg(long = "selector", short = 's', value_name = "SELECTOR")]
        selector_flag: Option<String>,
        /// Time to wait for navigation after click (milliseconds)
        #[arg(long, default_value = "500")]
        wait_ms: u64,
    },

    /// Fill text into an input field (works with React and other frameworks)
    Fill {
        /// Text to fill into the input
        text: String,
        /// CSS selector for the input element
        #[arg(long = "selector", short = 's', value_name = "SELECTOR")]
        selector: Option<String>,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url: Option<String>,
    },

    /// Wait for condition (selector, timeout, or load state)
    Wait {
        /// Target URL (positional)
        url: Option<String>,
        /// Condition to wait for (selector, timeout ms, or load state)
        #[arg(default_value = "networkidle")]
        condition: String,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
    },

    /// Page content extraction commands (text, html, snapshot, elements, etc.)
    #[command(subcommand)]
    Page(PageAction),

    /// Authentication and session management
    Auth {
        #[command(subcommand)]
        action: AuthAction,
    },

    /// Session lifecycle and inspection
    Session {
        #[command(subcommand)]
        action: SessionAction,
    },

    /// Manage the pw daemon for persistent browser sessions
    Daemon {
        #[command(subcommand)]
        action: DaemonAction,
    },

    /// Initialize a new playwright project structure
    Init {
        /// Project directory (defaults to current directory)
        #[arg(default_value = ".")]
        path: PathBuf,

        /// Template type: standard (full structure) or minimal (tests only)
        #[arg(long, short, default_value = "standard", value_enum)]
        template: InitTemplate,

        /// Skip creating playwright.config.js
        #[arg(long)]
        no_config: bool,

        /// Skip creating example test file
        #[arg(long)]
        no_example: bool,

        /// Use TypeScript for config and tests
        #[arg(long)]
        typescript: bool,

        /// Force overwrite existing files
        #[arg(long, short)]
        force: bool,

        /// Generate Nix browser setup script (for NixOS/Nix users)
        #[arg(long)]
        nix: bool,
    },

    /// Run the CDP relay server for the browser extension bridge
    Relay {
        /// Host to bind
        #[arg(long, default_value = "127.0.0.1")]
        host: String,
        /// Port to bind
        #[arg(long, default_value_t = 19988)]
        port: u16,
    },

    /// Connect to or launch a browser with remote debugging
    ///
    /// Once connected, all pw commands will use this browser instead of launching a new one.
    /// This is the recommended way to bypass bot detection - use your real browser.
    ///
    /// Examples:
    ///   pw connect --launch          # Launch Chrome with debugging enabled
    ///   pw connect --discover        # Find existing Chrome with debugging
    ///   pw connect ws://...          # Set endpoint manually
    ///   pw connect --clear           # Disconnect
    Connect {
        /// CDP WebSocket endpoint URL (e.g., ws://127.0.0.1:9222/devtools/browser/...)
        endpoint: Option<String>,
        /// Clear the saved CDP endpoint
        #[arg(long)]
        clear: bool,
        /// Launch Chrome with remote debugging enabled
        #[arg(long)]
        launch: bool,
        /// Discover and connect to existing Chrome with debugging enabled
        #[arg(long)]
        discover: bool,
        /// Kill Chrome process on the debugging port
        #[arg(long)]
        kill: bool,
        /// Remote debugging port (default: 9222)
        #[arg(long, short, default_value = "9222")]
        port: u16,
        /// Chrome profile directory to use (for --launch)
        #[arg(long)]
        profile: Option<String>,
    },

    /// Manage browser tabs
    #[command(subcommand)]
    Tabs(TabsAction),

    /// Manage protected URL patterns (tabs the CLI won't touch)
    ///
    /// Protected tabs are excluded from page selection and tab operations.
    /// Use this to prevent the CLI from accidentally navigating your PWAs or
    /// important tabs like Discord, Slack, etc.
    #[command(subcommand)]
    Protect(ProtectAction),

    /// Run commands from stdin in batch mode (for AI agents)
    ///
    /// Reads NDJSON commands from stdin and streams responses to stdout.
    /// Each line should be a JSON object with "id", "command", and "args" fields.
    ///
    /// Example input:
    ///   {"id":"1","command":"navigate","args":{"url":"https://example.com"}}
    ///   {"id":"2","command":"screenshot","args":{"output":"page.png"}}
    ///
    /// Use Ctrl+D (EOF) to exit batch mode.
    Run,
}

/// Project template type for init command
#[derive(Clone, Debug, ValueEnum, Default)]
pub enum InitTemplate {
    /// Full structure: tests/, scripts/, results/, reports/, screenshots/
    #[default]
    Standard,
    /// Minimal structure: tests/ only
    Minimal,
}

/// Output format for the read command
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, ValueEnum)]
pub enum ReadOutputFormat {
    /// Plain text
    Text,
    /// Cleaned HTML
    Html,
    /// Markdown (default)
    #[default]
    Markdown,
}

/// Page content extraction commands
#[derive(Subcommand, Debug)]
pub enum PageAction {
    /// Capture console messages and errors
    #[command(alias = "con")]
    Console {
        /// Target URL (positional, uses context when omitted)
        url: Option<String>,
        /// Time to wait for console messages (ms)
        #[arg(default_value = "3000")]
        timeout_ms: u64,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
    },

    /// Evaluate JavaScript and return result
    ///
    /// The expression can be provided positionally, via --expr/-e, or read from a file.
    /// When using named flags, the order doesn't matter.
    Eval {
        /// JavaScript expression (positional). Required unless --expr or --file is used.
        expression: Option<String>,
        /// Target URL (positional, uses context when omitted)
        url: Option<String>,
        /// JavaScript expression (named alternative to positional)
        #[arg(long = "expr", short = 'e', value_name = "EXPRESSION")]
        expression_flag: Option<String>,
        /// Read JavaScript expression from file (avoids shell argument limits for large scripts)
        #[arg(long = "file", short = 'F', value_name = "FILE")]
        file: Option<PathBuf>,
        /// Target URL (named alternative to positional)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
    },

    /// Get HTML content (full page or specific selector)
    Html {
        /// Target URL (positional, uses context when omitted)
        url: Option<String>,
        /// CSS selector (positional, uses last selector or defaults to html)
        selector: Option<String>,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
        /// CSS selector (named alternative)
        #[arg(long = "selector", short = 's', value_name = "SELECTOR")]
        selector_flag: Option<String>,
    },

    /// Get coordinates for first matching element
    Coords {
        /// Target URL (positional)
        url: Option<String>,
        /// CSS selector (positional)
        selector: Option<String>,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
        /// CSS selector (named alternative)
        #[arg(long = "selector", short = 's', value_name = "SELECTOR")]
        selector_flag: Option<String>,
    },

    /// Get coordinates and info for all matching elements
    CoordsAll {
        /// Target URL (positional)
        url: Option<String>,
        /// CSS selector (positional)
        selector: Option<String>,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
        /// CSS selector (named alternative)
        #[arg(long = "selector", short = 's', value_name = "SELECTOR")]
        selector_flag: Option<String>,
    },

    /// Get text content of element
    Text {
        /// Target URL (positional)
        url: Option<String>,
        /// CSS selector (positional)
        selector: Option<String>,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
        /// CSS selector (named alternative)
        #[arg(long = "selector", short = 's', value_name = "SELECTOR")]
        selector_flag: Option<String>,
    },

    /// Extract readable content from a web page
    ///
    /// Removes clutter (ads, navigation, sidebars) and extracts the main article content.
    /// Useful for reading articles, blog posts, and documentation.
    Read {
        /// Target URL (positional)
        url: Option<String>,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
        /// Output format: markdown (default), text, or html
        #[arg(long, short = 'o', default_value = "markdown", value_enum)]
        output_format: ReadOutputFormat,
        /// Include metadata (title, author, etc.) in output
        #[arg(long, short = 'm')]
        metadata: bool,
    },

    /// List interactive elements (buttons, links, inputs, selects)
    #[command(alias = "els")]
    Elements {
        /// Target URL (positional)
        url: Option<String>,
        /// Wait for elements with polling (useful for dynamic pages)
        #[arg(long)]
        wait: bool,
        /// Timeout in milliseconds for --wait mode (default: 10000)
        #[arg(long, default_value = "10000")]
        timeout_ms: u64,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
    },

    /// Get a comprehensive page model (URL, title, elements, text) in one call
    ///
    /// Returns structured page state that gives AI agents full context without
    /// multiple round-trips. Includes interactive elements with stable selectors
    /// and visible text content.
    #[command(alias = "snap")]
    Snapshot {
        /// Target URL (positional)
        url: Option<String>,
        /// Target URL (named alternative)
        #[arg(long = "url", short = 'u', value_name = "URL")]
        url_flag: Option<String>,
        /// Skip interactive element extraction (faster, text-focused)
        #[arg(long)]
        text_only: bool,
        /// Include full page text instead of just visible content
        #[arg(long)]
        full: bool,
        /// Maximum text length to extract (default: 5000)
        #[arg(long, default_value = "5000")]
        max_text_length: usize,
    },
}

#[derive(Subcommand, Debug)]
pub enum AuthAction {
    /// Interactive login - opens browser for manual login, then saves session
    Login {
        /// URL to navigate to for login (uses context when omitted)
        url: Option<String>,
        /// File to save authentication state to
        #[arg(short, long, default_value = "auth.json")]
        output: PathBuf,
        /// Wait time in seconds for manual login (default: 60)
        #[arg(short, long, default_value = "60")]
        timeout: u64,
    },

    /// Show cookies for a URL (uses saved auth if --auth provided)
    Cookies {
        /// URL to get cookies for
        url: Option<String>,
        /// Output format: json or table
        #[arg(short, long, default_value = "table")]
        format: String,
    },

    /// Show contents of a saved auth file
    Show {
        /// File to read authentication state from
        file: PathBuf,
    },

    /// Listen for cookies from browser extension
    ///
    /// Starts a WebSocket server that receives cookies from the pw browser extension.
    /// A one-time token is displayed for authentication.
    Listen {
        /// Host to bind
        #[arg(long, default_value = "127.0.0.1")]
        host: String,
        /// Port to bind
        #[arg(long, default_value_t = 9271)]
        port: u16,
    },
}

#[derive(Subcommand, Debug)]
pub enum DaemonAction {
    /// Start the daemon (use --foreground to run in terminal)
    Start {
        #[arg(long)]
        foreground: bool,
    },
    /// Stop the running daemon
    Stop,
    /// Show daemon status
    Status,
}

#[derive(Subcommand, Debug)]
pub enum SessionAction {
    /// Show session descriptor status for the active context
    Status,
    /// Remove stored session descriptor for the active context
    Clear,
    /// Start a reusable local browser session and persist its endpoint
    Start {
        /// Run with a visible (headful) browser window
        #[arg(long)]
        headful: bool,
    },
    /// Stop the reusable local browser session and remove descriptor
    Stop,
}

#[derive(Subcommand, Debug)]
pub enum TabsAction {
    /// List all open tabs
    List,
    /// Switch to a tab by index or URL pattern
    Switch {
        /// Tab index (0-based) or URL/title pattern to match
        target: String,
    },
    /// Close a tab by index or URL pattern
    Close {
        /// Tab index (0-based) or URL/title pattern to match
        target: String,
    },
    /// Open a new tab, optionally with a URL
    New {
        /// URL to open in the new tab
        url: Option<String>,
    },
}

#[derive(Subcommand, Debug)]
pub enum ProtectAction {
    /// Add a URL pattern to protect (e.g., "discord.com", "slack.com")
    Add {
        /// URL pattern to protect (substring match, case-insensitive)
        pattern: String,
    },
    /// Remove a URL pattern from protection
    Remove {
        /// URL pattern to remove
        pattern: String,
    },
    /// List all protected URL patterns
    List,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_screenshot_command() {
        let args = vec![
            "pw",
            "screenshot",
            "https://example.com",
            "-o",
            "/tmp/test.png",
        ];
        let cli = Cli::try_parse_from(args).unwrap();

        match cli.command {
            Commands::Screenshot {
                url,
                output,
                full_page,
                ..
            } => {
                assert_eq!(url.as_deref(), Some("https://example.com"));
                assert_eq!(output, Some(PathBuf::from("/tmp/test.png")));
                assert!(!full_page);
            }
            _ => panic!("Expected Screenshot command"),
        }
    }

    #[test]
    fn parse_screenshot_default_output() {
        let args = vec!["pw", "screenshot", "https://example.com"];
        let cli = Cli::try_parse_from(args).unwrap();

        match cli.command {
            Commands::Screenshot {
                url,
                output,
                full_page,
                ..
            } => {
                assert_eq!(url.as_deref(), Some("https://example.com"));
                assert_eq!(output, None);
                assert!(!full_page);
            }
            _ => panic!("Expected Screenshot command"),
        }
    }

    #[test]
    fn parse_page_html_command() {
        let args = vec!["pw", "page", "html", "https://example.com", "div.content"];
        let cli = Cli::try_parse_from(args).unwrap();

        match cli.command {
            Commands::Page(PageAction::Html { url, selector, .. }) => {
                assert_eq!(url.as_deref(), Some("https://example.com"));
                assert_eq!(selector.as_deref(), Some("div.content"));
            }
            _ => panic!("Expected Page Html command"),
        }
    }

    #[test]
    fn parse_wait_command() {
        let args = vec!["pw", "wait", "https://example.com", "networkidle"];
        let cli = Cli::try_parse_from(args).unwrap();

        match cli.command {
            Commands::Wait { url, condition, .. } => {
                assert_eq!(url.as_deref(), Some("https://example.com"));
                assert_eq!(condition, "networkidle");
            }
            _ => panic!("Expected Wait command"),
        }
    }

    #[test]
    fn verbose_flag_short_and_long() {
        let short_args = vec!["pw", "-v", "screenshot", "https://example.com"];
        let short_cli = Cli::try_parse_from(short_args).unwrap();
        assert_eq!(short_cli.verbose, 1);

        let long_args = vec!["pw", "--verbose", "screenshot", "https://example.com"];
        let long_cli = Cli::try_parse_from(long_args).unwrap();
        assert_eq!(long_cli.verbose, 1);

        let double_v = vec!["pw", "-vv", "screenshot", "https://example.com"];
        let double_cli = Cli::try_parse_from(double_v).unwrap();
        assert_eq!(double_cli.verbose, 2);
    }

    #[test]
    fn parse_cdp_endpoint_flag() {
        let args = vec![
            "pw",
            "--cdp-endpoint",
            "ws://localhost:19988/cdp",
            "navigate",
            "https://example.com",
        ];
        let cli = Cli::try_parse_from(args).unwrap();
        assert_eq!(
            cli.cdp_endpoint.as_deref(),
            Some("ws://localhost:19988/cdp")
        );
    }

    #[test]
    fn parse_relay_command() {
        let args = vec!["pw", "relay", "--host", "0.0.0.0", "--port", "3000"];
        let cli = Cli::try_parse_from(args).unwrap();
        match cli.command {
            Commands::Relay { host, port } => {
                assert_eq!(host, "0.0.0.0");
                assert_eq!(port, 3000);
            }
            _ => panic!("Expected Relay command"),
        }
    }

    #[test]
    fn invalid_command_fails() {
        let args = vec!["pw", "unknown-command", "https://example.com"];
        assert!(Cli::try_parse_from(args).is_err());
    }

    #[test]
    fn parse_click_with_named_flags() {
        // Test using named flags instead of positional args
        let args = vec![
            "pw",
            "click",
            "--url",
            "https://example.com",
            "--selector",
            "button.submit",
        ];
        let cli = Cli::try_parse_from(args).unwrap();

        match cli.command {
            Commands::Click {
                url,
                selector,
                url_flag,
                selector_flag,
                ..
            } => {
                // Positional args should be None
                assert!(url.is_none());
                assert!(selector.is_none());
                // Named flags should have values
                assert_eq!(url_flag.as_deref(), Some("https://example.com"));
                assert_eq!(selector_flag.as_deref(), Some("button.submit"));
            }
            _ => panic!("Expected Click command"),
        }
    }

    #[test]
    fn parse_page_eval_with_named_flags() {
        // Test eval with --expr and --url flags (order-independent)
        let args = vec![
            "pw",
            "page",
            "eval",
            "--url",
            "https://example.com",
            "--expr",
            "document.title",
        ];
        let cli = Cli::try_parse_from(args).unwrap();

        match cli.command {
            Commands::Page(PageAction::Eval {
                expression,
                url,
                expression_flag,
                url_flag,
                ..
            }) => {
                assert!(expression.is_none());
                assert!(url.is_none());
                assert_eq!(expression_flag.as_deref(), Some("document.title"));
                assert_eq!(url_flag.as_deref(), Some("https://example.com"));
            }
            _ => panic!("Expected Page Eval command"),
        }
    }

    #[test]
    fn parse_har_flags() {
        let args = vec![
            "pw",
            "--har",
            "network.har",
            "--har-content",
            "embed",
            "--har-mode",
            "minimal",
            "--har-omit-content",
            "--har-url-filter",
            "*.api.example.com",
            "navigate",
            "https://example.com",
        ];
        let cli = Cli::try_parse_from(args).unwrap();

        assert_eq!(
            cli.har.as_deref(),
            Some(std::path::Path::new("network.har"))
        );
        assert_eq!(cli.har_content, CliHarContentPolicy::Embed);
        assert_eq!(cli.har_mode, CliHarMode::Minimal);
        assert!(cli.har_omit_content);
        assert_eq!(cli.har_url_filter.as_deref(), Some("*.api.example.com"));
    }

    #[test]
    fn parse_har_defaults() {
        let args = vec!["pw", "navigate", "https://example.com"];
        let cli = Cli::try_parse_from(args).unwrap();

        assert!(cli.har.is_none());
        assert_eq!(cli.har_content, CliHarContentPolicy::Attach);
        assert_eq!(cli.har_mode, CliHarMode::Full);
        assert!(!cli.har_omit_content);
        assert!(cli.har_url_filter.is_none());
    }
}
