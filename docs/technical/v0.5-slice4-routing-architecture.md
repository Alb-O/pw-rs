# Version 0.5 Slice 4: Network Routing Architecture

**Date:** 2025-11-08
**Status:** Research Complete - Implementation Planned
**Related Version:** Version 0.5 Slice 4 - Network Route API Foundation

## Problem Statement

Implementing `page.route()` for network interception requires handling async closures in Rust. The challenge is to provide a Rust-idiomatic API that:

1. Matches Playwright's API across all language bindings (consistency goal)
2. Supports async handlers that can abort/continue requests
3. Handles thread safety and lifetime management correctly
4. Remains simple enough to implement and maintain

## API Design Options Considered

### Option 1: Trait-based Handler (Most Rust-idiomatic)

**Approach:**
```rust
// Define a trait for route handlers
trait RouteHandler: Send + Sync {
    fn handle(&self, route: Route) -> Pin<Box<dyn Future<Output = Result<()>> + Send + '_>>;
}

// Implement for closures
impl<F, Fut> RouteHandler for F
where
    F: Fn(Route) -> Fut + Send + Sync,
    Fut: Future<Output = Result<()>> + Send,
{
    fn handle(&self, route: Route) -> Pin<Box<dyn Future<Output = Result<()>> + Send + '_>> {
        Box::pin(self(route))
    }
}

// Usage
page.route("**/*.png", |route| async move {
    route.abort(None).await
}).await?;
```

**Pros:**
- ✅ Type-safe
- ✅ Idiomatic Rust trait pattern
- ✅ Flexible for different handler implementations

**Cons:**
- ❌ Complex to implement correctly with lifetimes
- ❌ Requires careful handling of `Pin` and `'_` lifetimes
- ❌ Higher maintenance burden

**Decision:** Not chosen - complexity outweighs benefits for this use case

---

### Option 2: Callback-based with Boxed Futures (Recommended)

**Approach:**
```rust
// Store handlers as boxed async functions
type RouteHandlerFn = Arc<dyn Fn(Route) -> Pin<Box<dyn Future<Output = Result<()>> + Send>> + Send + Sync>;

impl Page {
    pub async fn route<F, Fut>(&self, pattern: &str, handler: F) -> Result<()>
    where
        F: Fn(Route) -> Fut + Send + Sync + 'static,
        Fut: Future<Output = Result<()>> + Send + 'static,
    {
        // Wrap handler in Arc and store
        let handler = Arc::new(move |route: Route| -> Pin<Box<dyn Future<Output = Result<()>> + Send>> {
            Box::pin(handler(route))
        });

        // Store and register with protocol
        self.route_handlers.lock().unwrap().push(RouteHandlerEntry {
            pattern: pattern.to_string(),
            handler,
        });

        self.enable_network_interception(pattern).await?;
        Ok(())
    }
}

// Usage
page.route("**/*.png", |route| async move {
    route.abort(None).await
}).await?;
```

**Pros:**
- ✅ Simpler implementation than trait-based
- ✅ Matches Playwright's API in Python/JS/Java/.NET
- ✅ Boxed futures are common in async Rust (reasonable idiom)
- ✅ Can be implemented incrementally
- ✅ Straightforward lifetime management (`'static` requirements)

**Cons:**
- ⚠️ Requires boxing (small heap allocation per handler)
- ⚠️ Dynamic dispatch (minimal performance impact)

**Decision:** ✅ **CHOSEN** - Best balance of simplicity, consistency, and Rust idioms

---

### Option 3: Channel-based (Event-driven)

**Approach:**
```rust
impl Page {
    pub async fn route(&self, pattern: &str) -> Result<mpsc::Receiver<Route>> {
        // Return receiver that yields Route objects
    }
}

// Usage
let mut routes = page.route("**/*.png").await?;
while let Some(route) = routes.recv().await {
    route.abort(None).await?;
}
```

**Pros:**
- ✅ Very Rust-idiomatic (channel-based concurrency)
- ✅ Explicit control flow
- ✅ No boxing or dynamic dispatch

**Cons:**
- ❌ **Different API than other Playwright bindings** (breaks consistency goal)
- ❌ Requires user to spawn tasks for each pattern
- ❌ More complex usage pattern

**Decision:** Not chosen - violates cross-language consistency goal

---

## Chosen Architecture: Callback-based (Option 2)

### Implementation Structure

```rust
// In Page struct - add route handler storage
pub struct Page {
    base: ChannelOwnerImpl,
    // ... existing fields ...
    route_handlers: Arc<Mutex<Vec<RouteHandlerEntry>>>,
}

struct RouteHandlerEntry {
    pattern: String, // Glob pattern
    handler: Arc<dyn Fn(Route) -> Pin<Box<dyn Future<Output = Result<()>> + Send>> + Send + Sync>,
}

impl Page {
    pub async fn route<F, Fut>(&self, pattern: &str, handler: F) -> Result<()>
    where
        F: Fn(Route) -> Fut + Send + Sync + 'static,
        Fut: Future<Output = Result<()>> + Send + 'static,
    {
        // 1. Wrap handler in Arc with type erasure
        let handler = Arc::new(move |route: Route| -> Pin<Box<dyn Future<Output = Result<()>> + Send>> {
            Box::pin(handler(route))
        });

        // 2. Store in handlers list
        self.route_handlers.lock().unwrap().push(RouteHandlerEntry {
            pattern: pattern.to_string(),
            handler,
        });

        // 3. Call protocol to enable network interception
        self.enable_network_interception(pattern).await?;

        Ok(())
    }

    // Called when "route" event arrives from protocol
    fn on_route_event(&self, route: Route) {
        let handlers = self.route_handlers.lock().unwrap().clone();
        let url = route.request().url().to_string();

        // Find matching handler
        for entry in handlers.iter().rev() { // Last registered wins
            if matches_pattern(&entry.pattern, &url) {
                let handler = entry.handler.clone();
                tokio::spawn(async move {
                    if let Err(e) = handler(route).await {
                        eprintln!("Route handler error: {}", e);
                    }
                });
                break;
            }
        }
    }
}
```

### Pattern Matching Strategy

**Version 0.5a (Basic):** Simple substring matching
```rust
if url.contains(&entry.pattern) { ... }
```

**Version 0.5b (Full):** Glob pattern matching via `glob` crate
```rust
use glob::Pattern;

fn matches_pattern(pattern: &str, url: &str) -> bool {
    Pattern::new(pattern)
        .ok()
        .map(|p| p.matches(url))
        .unwrap_or(false)
}
```

### Protocol Integration

When `page.route()` is called:
1. Store handler in `route_handlers` vector
2. Send protocol command to enable network interception:
   ```json
   {
       "method": "setNetworkInterceptionEnabled",
       "params": { "enabled": true }
   }
   ```

When request matches a route:
1. Playwright server sends `"route"` event with Route object
2. Page's `on_event()` receives event, creates Route from protocol
3. `on_route_event()` matches URL against patterns
4. Handler invoked asynchronously via `tokio::spawn`

---

## Incremental Implementation Plan

### Slice 4a: Basic Route Infrastructure
**Goal:** Get ONE test passing with minimal implementation

**Scope:**
1. Add `route_handlers: Arc<Mutex<Vec<RouteHandlerEntry>>>` to Page
2. Implement `page.route()` with callback storage
3. Implement simple pattern matching (substring match)
4. Handle "route" event and invoke handler
5. Basic protocol integration (enable interception)

**Test Target:** `test_route_abort_basic`

**Why First:** Vertical slice - proves entire flow end-to-end

**Files to Modify:**
- `crates/playwright-core/src/protocol/page.rs` - Add route() method, handler storage
- `crates/playwright-core/src/protocol/frame.rs` - Handle route events (Page delegates to Frame)

---

### Slice 4b: Pattern Matching
**Goal:** Support proper glob patterns

**Scope:**
1. Add `glob` crate dependency to `Cargo.toml`
2. Replace substring matching with glob pattern matching
3. Support multiple handlers with priority (last registered wins)
4. Test pattern edge cases

**Test Targets:**
- `test_route_pattern_matching`
- `test_route_conditional_abort`

**Why Second:** Builds on working infrastructure, adds production-ready matching

**Files to Modify:**
- `crates/playwright-core/Cargo.toml` - Add glob dependency
- `crates/playwright-core/src/protocol/page.rs` - Upgrade pattern matching

---

### Slice 4c: Cross-browser & Polish
**Goal:** Production readiness

**Scope:**
1. Verify `route.continue()` works correctly
2. Cross-browser testing (Firefox, WebKit)
3. Error handling (handler errors, protocol errors)
4. Polish error messages

**Test Targets:** All remaining tests

**Why Last:** Completes feature with quality and compatibility

**Files to Modify:**
- `crates/playwright-core/src/protocol/route.rs` - Error handling improvements
- Tests for edge cases

---

## Key Design Decisions

### 1. Handler Storage: `Arc<Mutex<Vec<>>>`
**Rationale:**
- `Arc` allows sharing between Page and event handlers
- `Mutex` provides interior mutability (add/remove handlers)
- `Vec` maintains registration order (last wins)

**Alternative Considered:** `RwLock` - rejected because writes (route registration) are rare, reads (event handling) clone the vec anyway

### 2. Handler Spawning: `tokio::spawn`
**Rationale:**
- Handlers run independently (don't block event loop)
- Matches Playwright's async handler behavior
- Errors are logged but don't crash the page

**Alternative Considered:** Sequential execution - rejected because handlers may be slow (network calls, etc.)

### 3. Pattern Matching Order: Last Registered Wins
**Rationale:**
- Matches Playwright behavior in other bindings
- Allows override patterns (register more specific patterns later)

**Example:**
```rust
page.route("**/*", continue_handler).await?;      // Generic
page.route("**/*.png", abort_handler).await?;     // Specific (wins)
```

### 4. Type Erasure via Boxing
**Rationale:**
- Allows storing different closure types in same Vec
- Common pattern in async Rust (`Box<dyn Future>`)
- Performance impact negligible (handlers are infrequent)

**Alternative Considered:** Generic storage - rejected because can't store different closure types

---

## Thread Safety Analysis

### Data Races
**Protected by `Arc<Mutex<>>`:**
- ✅ Multiple pages can register routes concurrently
- ✅ Event handling can't race with route registration
- ✅ Handlers can be invoked concurrently (spawned independently)

### Lifetime Safety
**'static bound on handlers:**
- ✅ Handlers can outlive the `route()` call
- ✅ No dangling references when handlers execute
- ✅ Captured variables must be `Clone` or moved

---

## Performance Considerations

### Heap Allocations
1. **Per route registration:** 1 Arc allocation (handler wrapper)
2. **Per route event:** 1 tokio task spawn (small allocation)

**Impact:** Negligible - route registration is infrequent, events are async anyway

### Pattern Matching Performance
- **Slice 4a:** O(n) substring check per pattern (fast)
- **Slice 4b:** O(n) glob match per pattern (acceptable for typical use)

**Optimization Opportunity:** If >100 patterns, consider trie-based matching (future work)

---

## Comparison with Other Playwright Bindings

### playwright-python
```python
await page.route("**/*.png", lambda route: route.abort())
```
- Similar callback-based approach
- Python's GIL handles thread safety
- Our Rust version uses `Arc<Mutex>` for equivalent safety

### playwright-java
```java
page.route("**/*.png", route -> route.abort());
```
- Similar callback-based approach
- Java uses synchronization
- Our Rust version uses `Mutex` for equivalent safety

### playwright-javascript
```javascript
await page.route("**/*.png", route => route.abort());
```
- Similar callback-based approach
- Single-threaded event loop (no concurrency issues)
- Our Rust version explicitly handles concurrency with `Arc<Mutex>`

**Conclusion:** Our approach aligns well with other bindings while being properly Rust-idiomatic

---

## Testing Strategy

### Unit Tests
- Pattern matching logic (substring, glob)
- Handler storage and retrieval
- Priority ordering (last wins)

### Integration Tests (TDD)
- `test_route_abort_basic` - Single pattern abort
- `test_route_abort_with_error_code` - Error code variants
- `test_route_continue_basic` - Request continuation
- `test_route_request_access` - Handler can access request
- `test_route_pattern_matching` - Multiple patterns
- `test_route_conditional_abort` - Conditional logic in handler
- Cross-browser tests (Firefox, WebKit)

---

## Future Enhancements (Out of Scope for Slice 4)

### Slice 5: route.fulfill()
- Mock responses with custom content
- JSON response helpers
- File-based responses

### Unroute Support
```rust
impl Page {
    pub async fn unroute(&self, pattern: Option<&str>) -> Result<()> {
        // Remove handlers by pattern, or all if None
    }
}
```

### Route Handler Options
```rust
pub struct RouteOptions {
    pub times: Option<usize>, // Max invocations
}

page.route_with_options("**/*.png", handler, RouteOptions {
    times: Some(1), // Run once then auto-unroute
}).await?;
```

---

## References

- [Playwright Route API](https://playwright.dev/docs/api/class-page#page-route)
- [Rust async book - Pinning](https://rust-lang.github.io/async-book/04_pinning/01_chapter.html)
- [playwright-python implementation](https://github.com/microsoft/playwright-python/blob/main/playwright/_impl/_page.py)
- Version 0.5 Implementation Plan: `docs/implementation-plans/v0.5-advanced-testing.md`

---

## Decision Summary

**Chosen Approach:** Callback-based with boxed futures (Option 2)

**Rationale:**
1. ✅ Matches Playwright API across all language bindings
2. ✅ Reasonably Rust-idiomatic (boxed futures are common)
3. ✅ Simple enough to implement and maintain
4. ✅ Can be implemented incrementally in 3 sub-slices

**Implementation Versions:**
- **Slice 4a:** Basic infrastructure (substring matching, one test passing)
- **Slice 4b:** Glob pattern matching (production-ready)
- **Slice 4c:** Cross-browser & polish (complete feature)

**Next Step:** Begin Slice 4a implementation
